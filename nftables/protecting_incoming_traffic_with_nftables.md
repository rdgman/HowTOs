A guide on protecting incoming traffic with `nftables` and a list of useful `nc` aliases.

## Protecting Incoming Traffic with Nftables

`nftables` is the modern Linux kernel framework for packet filtering and classification, replacing the older `iptables`, `ip6tables`, `arptables`, and `ebtables` tools. It offers a more consistent syntax, better performance, atomic rule updates, and unified handling of different protocol families.

Here's a step-by-step guide to creating a basic firewall policy focused on protecting incoming traffic:

**1. Understand the Basics**

* **Tables:** Containers for chains. You typically use the `inet` family table to handle both IPv4 and IPv6 traffic simultaneously.
* **Chains:** Hooks into the network stack where rules are evaluated. Common base chains for filtering are:
    * `input`: For packets destined for the local machine.
    * `forward`: For packets routed through the machine.
    * `output`: For packets generated by the local machine.
* **Rules:** Define criteria (like protocol, port, IP address) and actions (like `accept`, `drop`, `reject`, `log`). Rules are processed sequentially within a chain.
* **Policies:** The default action for a chain if no rule matches a packet (usually `accept` or `drop`). A security best practice is to set the default policy for `input` and `forward` chains to `drop`.

**2. Installation and Enabling**

If `nftables` isn't installed, install it using your distribution's package manager (e.g., `sudo apt install nftables` or `sudo dnf install nftables`). Then, enable and start the service:
```bash
sudo systemctl start nftables
sudo systemctl enable nftables
```

**3. Creating a Basic Ruleset**

It's best practice to define rules in a configuration file, typically `/etc/nftables.conf`. Here is an example configuration that sets up a basic stateful firewall:

```nftables
#!/usr/sbin/nft -f

# Start by flushing the old ruleset to ensure a clean state
flush ruleset

# Create the main table using the 'inet' family for unified IPv4/IPv6 rules
table inet filter {
    # Chain for incoming traffic to the machine itself
    chain input {
        type filter hook input priority 0; policy drop; # Default policy: DROP unknown incoming traffic

        # --- Basic Acceptance Rules ---
        # Allow traffic from established and related connections (essential for stateful firewall)
        ct state established,related accept comment "Allow established/related connections"

        # Drop invalid packets early
        ct state invalid drop comment "Drop invalid packets"

        # Allow all traffic from the loopback interface (required for local services)
        iifname "lo" accept comment "Allow loopback traffic"

        # --- ICMP (Ping, etc.) ---
        # Allow essential ICMP types (e.g., echo-request for ping) - Be specific if needed
        # For IPv4
        ip protocol icmp icmp type { echo-request, echo-reply, destination-unreachable } limit rate 4/second accept comment "Accept limited ICMPv4"
        # For IPv6
        ip6 nexthdr icmpv6 icmpv6 type { echo-request, echo-reply, nd-neighbor-solicit, nd-neighbor-advert, nd-router-advert } limit rate 4/second accept comment "Accept limited ICMPv6/NDP"

        # --- Service-Specific Rules ---
        # Allow SSH (TCP port 22) connections
        # Consider adding 'ip saddr <your_admin_ip>' to restrict access
        tcp dport 22 accept comment "Allow SSH"
        # Optional: Rate limit SSH to mitigate brute-force attempts
        # tcp dport 22 limit rate 5/minute burst 5 packets accept comment "Allow rate-limited SSH"

        # Allow HTTP (TCP port 80)
        tcp dport 80 accept comment "Allow HTTP"

        # Allow HTTPS (TCP port 443)
        tcp dport 443 accept comment "Allow HTTPS"

        # --- Logging (Optional) ---
        # Log dropped packets (can be noisy, use judiciously)
        # log prefix "[nftables drop input] " flags all counter drop

        # Implicit drop for anything not matched above due to 'policy drop'
    }

    # Chain for traffic passing through the machine (e.g., if it's a router)
    chain forward {
        type filter hook forward priority 0; policy drop; # Default policy: DROP forwarded traffic
        # Add rules here if this machine acts as a router/gateway
        # Example: Allow forwarding from LAN to WAN if needed
        # iifname "eth_lan" oifname "eth_wan" accept
    }

    # Chain for outgoing traffic generated by the machine
    chain output {
        type filter hook output priority 0; policy accept; # Default policy: ACCEPT outgoing traffic
        # You might restrict output later if needed, but accept is a common default
    }
}
```

**4. Applying the Ruleset**

Save the rules above to `/etc/nftables.conf`. Then load them:

```bash
sudo nft -f /etc/nftables.conf
```

Check the loaded ruleset:

```bash
sudo nft list ruleset
```

**5. Best Practices for Security**

* **Default Deny:** Always start with a `policy drop` on `input` and `forward` chains and explicitly `accept` only necessary traffic.
* **Least Privilege:** Only open ports that are absolutely required for your services.
* **Stateful Filtering:** Always allow `ct state established,related` traffic early in your `input` chain.
* **Input Validation:** Drop `ct state invalid` packets.
* **Rate Limiting:** Apply rate limiting to services prone to brute-force attacks (like SSH) or flooding (like ICMP).
* **Source IP Restrictions:** Whenever possible, restrict access to sensitive services (like SSH) to known IP addresses or ranges using `ip saddr <address>` or `ip saddr @your_set`.
* **Logging:** Log dropped packets (especially initially) to troubleshoot issues, but be mindful of log volume.
* **Regular Review:** Periodically review your firewall rules to ensure they are still relevant and necessary.
* **Testing:** Test thoroughly after making changes to ensure legitimate traffic isn't blocked and unwanted traffic is.

This guide provides a solid foundation. You'll need to adjust the service-specific rules based on the applications running on your server.

## Netcat (`nc`) Aliases (~20 Examples)

Here are some useful aliases for the `nc` (netcat) command. These assume you are using a common version like the OpenBSD `nc` or Nmap's `ncat`. Some flags might differ slightly between versions. Add these to your shell configuration file (e.g., `~/.bashrc`, `~/.zshrc`).

```bash
# ~/.bashrc or ~/.zshrc

# --- Port Scanning ---
# 1. Verbose TCP connect scan with 3s timeout (Usage: ncscan <host> <port or range>)
alias ncscan='nc -vz -w 3'
# 2. Verbose UDP scan with 3s timeout (Usage: ncscanu <host> <port or range>)
alias ncscanu='nc -uvz -w 3'
# 3. Quick Zero-I/O TCP scan (Just check if port is open) (Usage: nczio <host> <port>)
alias nczio='nc -z'
# 4. Quick Zero-I/O UDP scan (Usage: ncziou <host> <port>)
alias ncziou='nc -uz'

# --- Listening ---
# 5. Simple TCP Listener (Verbose, Port) (Usage: nclisten <port>)
alias nclisten='nc -lvp'
# 6. Simple UDP Listener (Verbose, Port) (Usage: nclistenu <luvp> <port>)
alias nclistenu='nc -luvp'
# 7. Persistent TCP Listener (Ncat only, keeps listening after disconnect) (Usage: nclistenk <port>)
alias nclistenk='ncat -lkp'

# --- File Transfer ---
# Note: Use with caution on untrusted networks. Consider encryption (e.g., pipe through GPG or use SSH/SCP/SFTP).
# 8. Receive File (TCP Listener, redirects to file) (Usage: ncrecv <port> > <filename>)
alias ncrecv='nc -lvp'
# 9. Send File (Connects and sends file, exits after 1s quiet period) (Usage: ncsend <host> <port> < <filename>)
alias ncsend='nc -q 1'
# 10. Send File (OpenBSD nc style, exits on EOF) (Usage: ncsendN <host> <port> < <filename>)
alias ncsendN='nc -N'
# 11. Receive Directory (Listen, pipe to tar) (Usage: ncrecvdir <port> | tar xzvf -)
alias ncrecvdir='nc -lvp'
# 12. Send Directory (Tar, pipe to nc) (Usage: tar czvf - . | ncsend <host> <port>)
# (This is slightly more complex than a simple alias, showing the command structure)
# Alias for the sending part: alias ncsendtar='tar cz . | nc -q 1' # Usage: ncsendtar <host> <port>

# --- Simple Chat/Data Exchange ---
# 13. Start Chat Server (Listen on port) (Usage: ncchatserver <port>)
alias ncchatserver='nc -lvp'
# 14. Connect as Chat Client (Usage: ncchatclient <host> <port>)
alias ncchatclient='nc -v'

# --- HTTP/Banner Grabbing ---
# 15. Grab HTTP Headers (HEAD request) (Usage: nchttphead <host> 80)
alias nchttphead='printf "HEAD / HTTP/1.1\\r\\nHost: %s\\r\\nConnection: close\\r\\n\\r\\n" "$1" | nc -q 1' # Usage: nchttphead <host> [port, default 80]
# 16. Simple Banner Grab (Connect and show initial response) (Usage: ncbanner <host> <port>)
alias ncbanner='nc -v -w 3'

# --- Shell Execution (EXTREME CAUTION ADVISED!) ---
# WARNING: Binding a shell or executing commands via nc is a SIGNIFICANT security risk.
# Only use these in trusted environments or for specific testing/CTF scenarios.
# 17. Bind Shell Listener (Provides /bin/bash on connect) (Usage: ncbindshell <port>)
alias ncbindshell='nc -lvnp -e /bin/bash' # May require specific nc version or compilation flags
# 18. Reverse Shell Connector (Connects back, executes /bin/bash) (Usage: ncrevshell <host> <port>)
alias ncrevshell='nc -e /bin/bash' # May require specific nc version or compilation flags
# 19. Ncat Bind Shell (Ncat specific, more reliable) (Usage: ncatbindshell <port>)
alias ncatbindshell='ncat -lvnp --exec /bin/bash'
# 20. Ncat Reverse Shell (Ncat specific) (Usage: ncatrevshell <host> <port>)
alias ncatrevshell='ncat --exec /bin/bash'

# --- Protocol Forcing ---
# 21. Force IPv4 usage (Usage: nc4 -vz <host> <port>)
alias nc4='nc -4'
# 22. Force IPv6 usage (Usage: nc6 -vz <host> <port>)
alias nc6='nc -6'
```

After adding these to your `~/.bashrc` or `~/.zshrc`, reload your shell configuration (e.g., `source ~/.bashrc` or start a new terminal session) for the aliases to become active. Remember to replace placeholders like `<host>`, `<port>`, and `<filename>` with actual values when using the aliases.
